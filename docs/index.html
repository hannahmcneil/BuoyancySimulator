<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>  
    div.padded {  
      padding-top: 0px;  
      padding-right: 100px;  
      padding-bottom: 0.25in;  
      padding-left: 100px;  
    }  

    body {
      margin: 150px;
    font-size: 125%;
  }

  </style> 
<title>Hannah McNeil, Lee Hagaman, Walker Snedaker  |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">CS184 Final Project Milestone: Buoyancy Simulator</h1>

<h2 align="middle">Hannah McNeil, Lee Hagaman, Walker Snedaker</h2>

<h2 align="middle">Progress</h2>

<p>So far our team has finished setting up the basic framework for our project, as well as the construction of our particle system and mesh boat. Our code works as follows: all of our particles are initialized in a 1 x 1 x 1 cube in our scene. They are evenly spaced apart. Each particle of water has the same density and mass. Other attributes include current position, former position, velocity, and the accumulated forces acting on it. As for our boat, we constructed a mesh object using Blender.</p>

<p>Once we have initialized our points, we then begin the simulation. At each time step, we run one step of the simulation; while this code is not yet complete (it only takes into account the effect of gravity on each of the water points) we plan to fill it in with code to simulate fluid dynamics soon. Basically, this involves changing the position of each of the particles in predictable ways, based on the forces that are acting on them (nearest neighbors, gravity, solid surfaces/planes, etc.). We then determine if we should create a frame for our video. (This is because we might want to have more or fewer time steps between frames depending on what we want our framerate to be; this is one of the parameters to our program.) If so, then we go about the process of creating a DAE file.</p>

<p>Creating a DAE file first involves creating a mesh surface from our water points. The reason for this is that we only want to render the surface of the water; this saves on time, but involves creating a method for determining which particles are closest to the surface. This we have already implemented. We use a nearest-neighbors search to determine (for every point) if that point is significantly farther from the average of its neighbors. If it is, then we consider it a surface point. We then have a collection of all the coordinates of our surface points. We are using the CGAL library in order to reconstruct a mesh surface based on these points. We use the Poisson surface reconstruction function to generate a mesh via Delaunay refinement.</p>

<p>The next step is to use our newly constructed mesh to create a Collada file that can then be rendered. We place our mesh object into a Cornell Box scene (using the CB scenes from previous projects as a template) and then render this using previously-implemented functionality. This creates the PNG files that serve as our frames, which we then reconstruct by  hand into a movie of our simulation.</p>

<h2 align="middle">Preliminary Results</h2>

<p>Preliminary results show that we are able to construct our initial water mesh object and have it fall to the ground under the effects of gravity. (Currently, we are only using the 10 nearest neighbors in our code to decide if a given point is on the surface, with a tolerance distance of 0.1. We may change these values slightly to see if it gives us a more accurate representation.)</p>

<h2 align="middle">Future Plans/Changes</h2>

<p>The next step is obviously to complete the simulation by adding realistic fluid dynamics, as well as methods that detect plane and self-collisions. Once this is done, we will be able to render a more realistic scene. Since we already have our mesh boat, we will place this in our scene after perfecting the water particle self-collisions. In conclusion, we still must implement functionality for the following:</p>

<ul>
  <li>Particle self-collisions; forces & fluid dynamics</li>
  <li>Particle-plane collisions (this can be applied to the walls of the Cornell Box and the boat itself); fluid-solid dynamics</li>
  <li>Plane-plane collisions (between boat and walls); this may not be necessary if we constrain the boatâ€™s position</li>
  <li>Place boat mesh in scene</li>
  <li>Fine-tune the way we construct our surface mesh</li>
</ul>


</div>
</body>
</html>